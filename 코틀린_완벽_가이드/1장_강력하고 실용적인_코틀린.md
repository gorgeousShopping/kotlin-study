- [강력하고 실용적인 코틀린](#강력하고-실용적인-코틀린)
  - [코틀린이란 무엇인가?](#코틀린이란-무엇인가)
    - [안정성](#안정성)
    - [다중 패러다임](#다중-패러다임)
    - [간결성과 표현력](#간결성과-표현력)
    - [상호 운용성](#상호-운용성)
    - [다중 플랫폼](#다중-플랫폼)
  - [코틀린 생태계](#코틀린-생태계)
    - [코루틴](#코루틴)
    - [테스트](#테스트)
    - [안드로이드 개발](#안드로이드-개발)
    - [웹 개발](#웹-개발)
    - [코틀린 시작하기](#코틀린-시작하기)

---

# 강력하고 실용적인 코틀린

## 코틀린이란 무엇인가?

**코틀린**은, **안정성, 간결성, 상호 운용성**을 강조하는 다중 패러다임, 다중 플랫폼 프로그래밍 언어.

### 안정성

- 코틀린의 설계 목표
  - 자바보다 더 안전성을 보장하는 언어를 설계하되, 자바보다는 개발자의 생산성을 덜 해치는 언어를 만드는 것

- 타입 추론
  - 개발자가 명시적으로 타입을 지정하지 않아도 된다. (cf. 자바 10에도 지역변수에 대한 타입 추론이 도입됨)
- 널이 될 수 있는 타입 지정
  - null의 사용을 제한하며, 악명 높은 NPE 예외를 좀 더 쉽게 방지할 수 있음
- 스마트 캐스트
  - 타입을 안전하게 변환하고, 실행 시점에 타입 캐스트 오류를 방지할 수 있다.


### 다중 패러다임

- 초기: `객체 지향 패러다임` + `함수형 프로그래밍` 지원
- 코틀린 언어가 성장하면서 2가지 프로그래밍 패러다임을 더 지원함
  - `도메인 특화 언어(Domain Specific Language, DSL)`: 선언적 스타일의 코딩 가능
  - `동시성 프로그래밍`



### 간결성과 표현력

- 개발자의 생산성은 누가 짜던간에, 빠르게 읽고 이해할 수 있는 코드를 작성할 수 있는지와 주로 연관이 되어 있음.
- 따라서 언어의 간결성, 프로그래머의 의도를 잡음 정보 없이 명확하게 표현할 수 있는 것이 프로그래밍 언어 세계에선 중요함.
- 코틀린에서는 자바에서 쓰는 게터, 세터, 익명 클래스 등 악명높은 불필요한 준비 코드를 제거함.
- 코틀린의 이러한 특성은 DSL의 발전과 밀접히 연관됨 => 잡음 최소화, 간결화

### 상호 운용성

- `코틀린 <-> 자바` : 상호 호환 가능함
- 또한, 코틀린이 JVM 이외의 JS 플랫폼이나 Native App인 C/c++/Objective C/Swift 등과 상호 작용까지 포함하는 범위로 확장됨

### 다중 플랫폼

- 아직은, JVM과 안드로이드가 코틀린 개발의 주 대상이지만, 요즘 코틀린은 다음과 같은 플랫폼도 지원함
  - 브라우저나 노드(Node.js) 애플리케이션, 자바스크립트 라이브러리까지 포함하는 자바스크립트 지원
  - macOS, Linux, Windows 라이브러리 및 애플리케이션을 포함하는 네이티브 지원

- 코틀린 1.3 버전부터 다중 플랫폼 개발을 지원


## 코틀린 생태계

- [놀라운 코틀린](https://kotlin.link) : 코틀린 커뮤니티 측에서 사용할 수 있는 라이브러리와 프레임워크 목록을 이 사이트에 계속 업데이트하고 있음
- 코틀린이 제공하는 좋은 자바 상호 운용성 덕분에, 기존 자바 라이브러리가 주는 이익을 활용할 수 있음

### 코루틴

- 코틀린에는 일시 중단 가능한 계산(suspendable computation)이라는 개념이 존재한다.
- 덕분에, async/await, future, promise, actor 등 **동시성 관련 프로그래밍 패턴을 지원**한다.
- 코루틴 프레임워크는 서버, 모바일, 데스크탑 관계 없이 **코틀린 애플리케이션에서 동시성 문제를 해결할 수 있는 강력하고 우아하며 쉽게 확장 가능한 해법을 제공**한다.

> 코루틴에 포함된 주요 기능

- 스레드에 대한 더 가벼운 대안
- 유연한 스레드 디스패치 메커니즘
- 일시 중단 가능한 시퀀스와 이터레이터
- 채널을 사용한 메모리 공유
- 액터를 통해 메시지 전송 방식으로 상태 공유

### 테스트

- `JUnit`, `TestNG`, `Mockito`와 같은 익숙한 자바 테스트 프레임워크 중 일부를 그대로 코틀린에 적용 가능
- `Mockito-Kotlin` : 유명한 `Mockito` framework를 확장한 것으로 코틀린 객체 모킹을 단순화 해줌
- `Spek` : 행위 주도(behavior-driven) 테스트 프레임워크로, `Jasmine`이나, `Gherkin` 스타일의 테스트 케이스 정의를 지원함.
- `KoTest`: 스칼라 테스트(ScalarTest)에 의해 영감을 얻은 프레임워크, 유연한 테스트 정의와 단언문을 지원함

### 안드로이드 개발

- 구글이 코틀린을 1급 안드로이드 언어로 선언
  - 이제 안드로이드 도구들은 코틀린의 특징을 염두에 두고 설계되고 개발될 것
  - `Dagger`, `ButterKnife`, `DBFlow` 등 여러 프레임워크와 상호 운용성을 얻을 수 있음
  - `Anko`
    - 코틀린 라이브러리 중 하나
    - 안드로이드 앱 개발을 단순화해줌.
    - 예를 들면 SQLite에 대한 query DSL, UI 미리 보기 플러그인(동적 레이아웃 합성 영역 특화 언어: a.k.a. Anko Layouts) 등이 있다.
  - `Kotlin Android Extension`, `Jetpack` 등

- 코틀린 안드로이드 확장을 말해보자면.....
  - 구체적으로 말하면 데이터 바인딩을 해주는 컴파일러 플러그인
  - 이를 사용하면 악명 높은 `findViewById()` 호출 피할 수 있음
  - 뷰 캐싱 지원
  - 사용자가 정의한 클래스에 대해 Parcelable 구현을 자동 생성해줌 
- 위와 같은 확장으로 인해 순수 코틀린 프로젝트에서는 버터나이프 같은 외부 프레임 워크를 이제 사용 안해도 됨.

### 웹 개발

- Spring 5.0이나 Vert.x3.0 같은 유명 프레임워크들은 코틀린용 확장 제공
- `Ktor`
  - JetBrains에서 만든, 비동기 서버와 클라이언트 애플리케이션 작성을 위한 프레임 워크
- `kotlinx.html`
  - HTML 문서를 만들기 위한 DSL
- `Kodein`
  - 의존 관계 주입 프레임워크

### 코틀린 시작하기

- Project 설정에서 Target JVM 버전은, **컴파일러가 생성할 바이트 코드(자바 가상 머신이 실행할 수 있는 명령어 코드)** 의 버전을 결정한다. 
- `out` 디렉터리는 컴파일러가 생성한 바이트 코드가 들어간다. 프로젝트를 처음 만든 경우, 이 디렉터리가 보이지 않으나, 코드를 한 번 이상 빌드하면 이 디렉터리가 생성됨.

```kt
println("Hello World")
```
위 코드는 JVM 컴파일을 한다면 다음과 같다.

```java
System.out.println("Hello World")
```

- JVM 진입점은 반드시 정적 클래스 메서드(static class method)여야 하는데, 어떻게 클래스를 정의하지 않고도 실행할 수 있을까?
  - 그 이유는 명시적으로 클래스를 정의하지는 않았지만, 코틀린 컴파일러가 뒤에서 자동으로 클래스를 하나 만들고, 그 안에 우리가 작성한 main() 함수를 호출하는 진입점을 넣어주기 때문이다.
  - 이와 관련해서는 자바 상호 운융성에서 facade 라는 클래스를 살펴보도록 하자.
  - 파사드 클래스는 코틀린/자바 상호 작용에서 가장 중요한 측면을 구성한다.

> REPL

- **R**ead/**E**valuate/**P**rint **L**oop 의 약자
- 대화형 셸
- 코드를 빨리 테스트하거나 라이브러리 함수를 실험해볼 수 있음
- IntelliJ > Tool > Kotlin > REPL
![](/images/2022-11-15-01-49-57.png)

> 코틀린 놀이터

- REPL과 온라인 IDE의 역할을 하는 온라인 도구
- https://play.kotlinlang.org
- 코드 편집기, 문법과 오류 하이라이팅, 코드 완성, 콘솔 프로그램 실행기 등 여러가지 기능 제공