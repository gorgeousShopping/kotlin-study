- [2장. 코틀린 언어 기초](#2장-코틀린-언어-기초)
- [2.1 기본 문법](#21-기본-문법)
  - [1.1 주석](#11-주석)
  - [1.2 변수 정의하기](#12-변수-정의하기)
    - [1.3 식별자](#13-식별자)
    - [1.4 가변 변수](#14-가변-변수)
    - [1.5 식과 연산자](#15-식과-연산자)
  - [2.2 기본 타입](#22-기본-타입)
    - [2.1 정수 타입](#21-정수-타입)
    - [2.2 부동소수점 수](#22-부동소수점-수)
    - [2.3 산술 연산](#23-산술-연산)
    - [2.4 비트 연산](#24-비트-연산)
    - [2.5 문자 타입 Char](#25-문자-타입-char)
    - [2.6 수 변환](#26-수-변환)
    - [2.7 불 타입과 논리 연산](#27-불-타입과-논리-연산)
    - [2.8 비교와 동등성](#28-비교와-동등성)
  - [2.3 문자열](#23-문자열)
    - [3.1 문자열 템플릿](#31-문자열-템플릿)
    - [3.2 기본 문자열 연산](#32-기본-문자열-연산)
  - [2.4 배열](#24-배열)
    - [4.1 배열 정의하기](#41-배열-정의하기)
    - [4.2 배열 사용하기](#42-배열-사용하기)

---
# 2장. 코틀린 언어 기초

# 2.1 기본 문법

## 1.1 주석

```kotlin
// 한줄짜리 주석

/*
여러줄 주석
 */

/**
 * kDoc 여러 줄 주석
 */
```

## 1.2 변수 정의하기

```kotlin
val timeInSeconds = 15
```

- val 키워드 : 값을 뜻하는 value에서 유래 → 변경할 수 없는 값을 의미
- 변수 식별자 : 새 변수에 이름을 부여하고, 나중에 이를 가리킬 때 사용
- 변수의 초깃값을 정의하는 식: = 기호 뒤에 온다.

사용자에게 정수 두 개를 입력받아 그 두 수의 합을 표시하는 프로그램 예제

```kotlin
private fun sumInputValue() {
    //지역변수 a,b
    val a: Int = readLine()!!.toInt() //타입 명시
    val b = readLine()!!.toInt() //타입 생략 가능(타입추론 기능)
    println(a + b)
}
```

- `!!` 는 널 아님 단언(not-null  assertion)으로, `!!` 앞의 결과가 null인 경우, 예외를 발생시킨다.
  - 이는 확실하지 않은 값에 대해 뒤의 함수(여기서는 toInt())를 호출하지 못하게 막음으로써 널로 인한 오류를 방지한다.

- `a`와 `b`와 같은 변수를 **지역 변수**라고 한다.

- 이와 별도로 코틀린에서는 프로퍼티(property)라는 변수와 비슷한 값을 정의할 수 있다.

  값을 그대로 읽거나 쓰는 변수와 달리, 프로퍼티에서는 값을 읽거나 쓸 때 계산을 수행할 수 있다.

- 타입을 명시할 때는 변수 이름뒤에 콜론(:)을 표시하고 그 뒤에 타입을 적는다.

- 타입추론이 되기 때문에 타입을 생략할 수 있다.

  - **타입추론** : 컴파일러가 코드의 문맥에서 타입을 도출해주는 언어 기능

변수 초기화

```kotlin
private fun initialValue() {
    // 초기값을 생략하고 나중에 다른 문에서 변수 초기화 가능
    val text: String //타입 명시 필수
    text = "Hello"
    println(text) //변수를 읽기 전에 변수를 초기화해야 함
}
```

### 1.3 식별자

- 식별자는 오직 문자, 숫자, 밑줄 문자(_)만 포함한다. 숫자로 식별자를 시작할 수 없다.

- 밑줄로만 이뤄질 수도 있다. 하지만 `_`, `__` , `___` 등은 모두 미리 예약된 식별자이므로 일반적인 식별자로는 사용될 수 없다.

- 하드 키워드(val, fun등)를 식별자로 쓸 수 없다.

  - 소프트 키워드(import 등)는 특별한 문맥에서만 키워드로 간주되고, 그런 문맥이 아닌 경우에는 일반적인 식별자로 쓰일 수 있다.
  - 하드 키워드, 소프트 키워드 목록은 [Kotlin docs](https://kotlinlang.org/docs/keyword-reference.html)에서 확인 가능

- 코틀린 식별자에는 달러 기호($)를 쓸 수 없다.

- 작은역따옴표(`)로 감싼 식별자

  - 빈 문자열을 제외한 아무 문자열이나 와도 된다.

  ```kotlin
  val `fun` = 1 // OK
  val `name with spaces` = 2 // OK
  ```

  - 가독성을 위해 이런 식별자는 사용하지 말자 (테스트케이스 메서드 이름을 정할 때는 예외)
  - 이런 식별자를 허용하는 주된 이유는 자바에서 식별자로 사용할 수 있는 단어가 코틀린에서 키워드(ex. fun)인데 코틀린에서 자바에서 정의한 식별자를 가져와 써야할 때가 있기 때문이다.

### 1.4 가변 변수

- 불변 변수

  - 한번 초기화하면 다시는 갑승ㄹ 대입할 수 없는 변수

  - `val` 키워드

  - 가능하면 불변 변수를 많이 사용하자

    - 함수가 부수효과를 일으키지 못한다. 함수형 스타일 코드를 장려할 수 있다.

      이로 인해 코드에 대한 추론이 쉬워진다.

- 가변 변수

  - 변수 값을 언제든 바꿀 수 있다.
  - `var` 키워드
  - 처음 변수에 값을 대입할 때 추론된 변수 타입은 계속 유지된다.

- 복합 대입 연산이라는 대입과 +, -, *, /, % 등의 이항 연산을 조합한 연산도 제공한다.

  ```kotlin
  val result = 3
  result *= 10 // result = result * 10
  result += 6  // result = result + 6
  ```

- **코틀린 대입은 문(statement)이다. 따라서 아무 값도 돌려주지 않는다.**

  이로 인해 코틀린에서는 자바의 `a = b = c` 와 같은 대입문 연쇄를 쓸 수 없다. (복합 대입 연산도 마찬가지)

- 증가(++), 감소(--) 연산 가능. 전위(prefix)나 후위(postfix) 연산자로 쓸 수 있다.

### 1.5 식과 연산자

코틀린 식을 다음과 같이 분류할 수 있다.

- 각 타입에 속하는 구체적인 값을 표현하는 **리터럴**

  ex) 12, 3.56

- 변수/프로퍼티 **참조**와 **함수 호출**

  ex) a.readLine(), “abc”.length, “12”.toInt()

- 전위와 후위 단항 연산

  ex) -a, ++b, c--

- 이항 연산

  ex) a + b, 2 * 3, x < 1

- 모든 식은 정해진 타입이 있다.

  이 타입은 연산이 만들어내는 값의 범위와 값에 허용되는 연산을 결정한다.

  ex) 리터럴 `1` : Int 타입, 식 `readLine()!!` : String 타입

- 변수 참조와 함수 호출에 점(.)으로 구분된 수신 객체(receiver) 연산을 포함시킬 수 있다.

  ex) `readLine()!!.toInt()` :  `readLine()!!` 이 만들어낸 값의 문맥에서 String에 정의된 `toInt()` 함수를 호출한다.

- 단항과 이항 연산마다 연산 순서를 결정하는 우선순위가 정해져 있다.

| 분류                | 연산자                    | 예제                | 우선순위를 감안한 해석 |
| ------------------- | ------------------------- | ------------------- | ---------------------- |
| 후위                | ++ -- .                   | a*b++               | a*(b++)                |
|                     |                           | ++b--               | ++(b--)                |
|                     |                           | a*b.foo()           | a*(b.foo())            |
| 전위                | + - ++ -- !               | +a*b                | (+a)*b                 |
|                     |                           | ++a*b               | (++a)*b                |
|                     |                           | !a \|\| b           | (!a) \|\| b            |
| 곱셈                | *, /, %                   | a*b + c             | (a*b) + c              |
|                     |                           | a – b%c             | a - (b*c)              |
| 덧셈                | +, -                      | a + b and c         | (a + b) and c          |
| 중위                | 이름이 붙은 중위 연산자들 | a < b or b < c      | (a < (b or b)) < c     |
|                     |                           | a == b and b == c   | (a == b) and (b == c)  |
| 비교                | < > <= >=                 | a < b == b < c      | (a < b) == (b < c)     |
|                     |                           | a < b && b < c      | (a < b) && (b < c)     |
| 동등                | == !=                     | a == b  \|\| b != c | (a == b) \|\| (b != c) |
| 논리곱(conjunction) | &&                        | a \|\| b && c       | a \|\| (b && c)        |
| 논리합(disjunction) | \|\|                      | a && b \|\| c       | (a && b) \|\| c        |
| 대입                | = += -= *= /= %=          | a = b*c             | a = (b*c)              |
|                     |                           | a *= a + b          | a *= (a + b)           |

우선순위가 같은 이항 연산자는 왼쪽에서 오른쪽으로 순서대로 계산된다.

```kotlin
a.foo().bar()                     // (a.foo()).bar()
a * b % c                         // (a * b) % c
(a == 1) or (b < 1) and (c > 1)   // ((a == 1>) or (b < 1>)) and (c > 1)
```

## 2.2 기본 타입

코틀린에서는 똑같은 타입(**예:** Int)이 문맥에 따라 원시 타입과 참조 타입을 가리키기 때문에 이런 구분이 약간 모호하다. 자바에는 원시 타입을 감싸는 특별한 박싱 타입(boxing type)이 있지만, **코틀린은 필요할 때 암시적으로 박싱을 수행**한다.

**자바와 달리 모든 코틀린 타입은 근본적으로 어떤 클래스 정의를 기반으로 만들어진다. 이 말은 Int와 같이 원시 타입과 비슷한 타입들도 메서드와 프로퍼티를 제공한다는 뜻이다.** 예를 들어 1.5.toInt()라는 식으로 1.5에 대해 Double 타입에 정의된 toInt() 메서드를 호출할 수 있다. 이 메서드는 Double 값을 Int 값으로 변환해준다.

### 2.1 정수 타입

코틀린에는 정수를 표현하는 네 가지 기본 타입이 있다.

| 이름  | 크기(바이트) | 범위                | 대응하는 자바 타입 |
| ----- | ------------ | ------------------- | ------------------ |
| Byte  | 1            | -128 .. 127         | Byte               |
| Short | 2            | -32768 .. 32767     | Short              |
| Int   | 4            | -(2^31) .. (2^31)-1 | Int                |
| Long  | 8            | -(2^63) .. (2^63)-1 | Long               |

- 수 리터럴에 _를 넣어서 가독성을 높일 수 있다. `val n = 34_721_189`

- 리터럴 자체의 타입은 그 수를 2진수로 표현했을 때의 크기에 따라 Int일 수도 있고 Long일 수도 있다. 하지만 범위만 맞으면 수 리터럴을 크기가 더 작은 타입의 변수에 대입해도 된다.

- 리터럴에 `L`이나 `l`을 접미사로 붙이면 Long 타입이 된다.

  ```kotlin
  val hundredLong = 100L       // OK: Long으로 타입이 추론됨
  val hundredInt: Int = 100L   // Error: assigning Long to Int
  ```

- 앞에 0b(2진수)나 0x(16진수)를 붙여서 2진수나 16진수로 수 리터럴을 작성할 수 있다.

  ```kotlin
  val bin = 0b10101 // 21
  val hex = 0xF9    // 249
  ```

- 코틀린은 8진수를 지원하지 않는다. 수 리터럴의 경우 0을 표현하는 경우가 아니라면 맨 앞에 0이 올 수 없다.

  ```kotlin
  val zero = 0       // OK
  val zeroOne = 01   // Error
  ```

- 10과 같은 음수는 기술적으로는 리터럴이 아니다. 음수는 단항 음수 연산자(-)를 리터럴에 적용한 식이다. (문법 구조가 그렇다는 것이고, 바이트코드를 생성할 때는 -n 이라는 음수 상수를 사용한다.)

  ```kotlin
  val neg = -10
  val negHex = -0xFF
  ```

- 각 정수 타입에는 최솟값(MIN_VALUE)과 최댓값(MAX_VALUE)을 포함하는 상수 정의가 들어있다. 이런 상수를 사용하려면 앞에 타입 이름을 붙여야 한다.

  ```kotlin
  Short.MIN_VALUE     // -32768
  Short.MAX_VALUE     // 32767
  Int.MAX_VALUE + 1   // -2147483648(정수 오버플로(overflow))
  ```

### 2.2 부동소수점 수

- Float와 Double을 제공한다.

정수 부분과 소수 부분을 나눠 소수점(.)을 찍는다.

```kotlin
val pi = 3.14
val one = 1.0
```

정수 부분이 비어있는 경우 정수 부분을 0으로 간주한다. 하지만 소수점을 남기면서 소수 부분을 생략할 수는 없다.

```kotlin
val quarter = .25 // 0.25
val one = 1.      // Error: Expecting an element
val two = 2       // 오류는 아니지만, 정수 리터럴임
```

코틀린은 **과학적 표기법(scientific notation) 리터럴을 허용**한다. 과학적 표기법에서는 e나 E 뒤에 10을 몇 번 거듭제곱하는지를 알려주는 숫자가 온다.

```kotlin
val pi = 0.314E1        // 3.14 = 0.314*10
val pi100 = 0.314E3     // 314.0 = 0.314*1000
val piOver100 = 3.14E-2 // 0.0314 = 3.14/100
val thousand = 1E3      // 1000.0 = 1*1000
```

과학적 표기법에서는 소수 부분(소수점 포함)을 생략할 수 있다.

- **부동소수점 리터럴의 타입은 디폴트로 Double이다.** `f`나 `F`를 리터럴 뒤에 붙이면 Float 타입이 된다.

  (f나 F를 붙이는 경우 소수점을 포함한 소수 부분을 생략할 수 있다)

  ```kotlin
  val pi = 3.14f
  val one = 1f
  ```

- 자바에서는 D나 d를 부동소수점 리터럴 뒤에 붙여서 강제로 double 타입으로 만들 수 있다(**예** 1.25d). 하지만 코틀린에서는 이런 접미사를 허용하지 않는다.

  Float 리터럴이 Double 타입으로 자동 변환되지 않는다.

  ```kotlin
  val pi: Double = 3.14f // Error
  ```

- 자바 6+와 달리 코틀린에서는 Double이나 Float의 16진 리터럴을 지원하지 않는다.

### 2.3 산술 연산

| 연산    | 뜻                         | 예제          | 결과 |
| ------- | -------------------------- | ------------- | ---- |
| +(단항) | 원래 값과 같은 값          | +2            | 2    |
| -(단항) | 원래 값의 부호를 반전한 값 | -2            | -2   |
| +       | 덧셈                       | 2 + 3         | 5    |
| -       | 뺄셈                       | 1 - 3         | -2   |
| *       | 곱셈                       | 3 * 4         | 12   |
| /       | 나눗셈                     | 7/4           | 1    |
|         |                            | -7/4          | -1   |
|         |                            | 7/(-4)        | -1   |
|         |                            | (-7)/(-4)     | 1    |
|         |                            | 6.5/2.5       | 2.6  |
|         |                            | -6.5/2.5      | -2.6 |
|         |                            | 6.5/(-2.5)    | -2.6 |
|         |                            | (-6.5)/(-2.5) | 2.6  |
| %       | 나머지                     | 7%4           | 3    |
|         |                            | -7%4          | -3   |
|         |                            | 7%(-4)        | 3    |
|         |                            | (-7)%(-4)     | -3   |
|         |                            | 6.5%2.5       | 1.5  |
|         |                            | -6.5%2.5      | -1.5 |
|         |                            | 6.5%(-2.5)    | 1.5  |
|         |                            | (-6.5)%(-2.5) | -1.5 |

- 나눗셈 연산자 : 항상 0 쪽으로 내림한 결과

- **나머지 연산 : 결과는 항상 피제수와 같은 부호**

- `floorDiv()` : 나눈 몫을 계산 (몫을 더 작은 정수로 내림)

- `mod()` : 나머지를 계산 (`a - a.floorDiv(b)*b` 를 반환. 항상 b의 부호와 같다.)

  ```kotlin
  println(7.floorDiv(4))       // 1 (Why? 1(floorDiv) * 4 + 3(mod))
  println((-7).floorDiv(4))    // -2 (Why? -2(floorDiv) * 4 + 1(mod))
  println(7.floorDiv(-4))      // -2 (Why? -2(floorDiv) * -4 + -1(mod))
  println((-7).floorDiv(-4))   // 1 (Why? 1(floorDiv) * -4 + -3(mod))
  println(7.mod(4))            // 3 (Why? 1(floorDiv) * 4 + 3(mod))
  println((-7).mod(4))         // 1 (Why? -2(floorDiv) * 4 + 1(mod))
  println(7.mod(-4))           // -1 (Why? -2(floorDiv) * -4 + -1(mod))
  println((-7).mod(-4))        // -3 (Why? 1(floorDiv) * -4 + -3(mod))
  ```

- 단항 +/- 연산 시 Byte와 Short는 Int를 반환한다.

  ```kotlin
  val byte: Byte = 1
  -byte      // -1: Int
  ```

- 산술 연산에서 명시적인 타입 변환을 하지 않아도 여러 수 타입을 혼용할 수 있다.

  결과는 인자 중 더 큰 의미를 지니는 타입이 된다.

### 2.4 비트 연산

- Int와 Long은 비트 수준의 연산을 지원한다.
- **inv**는 이항 연산이나 단항 연산이 아니라 **점 표기법으로 호출하는 메서드**일 뿐이다.
- 코틀린 1.1부터는 Byte와 Short에도 or, xor, inv를 호출할 수 있다.
- 자바에서의 비트 연산자 &, |, ^, ~, <<, >>, >>>를 코틀린은 지원하지 않는다. 대신 이에 대응하는 and, or, xor, inv, shl, shr, ushr을 사용해야 한다.

| 연산 | 뜻                      | 예제                  | 결과                                   |
| ---- | ----------------------- | --------------------- | -------------------------------------- |
| shl  | 왼쪽 시프트(shift)      | 13 shl 2(-13) shl 2   | 52: 0...00110100-52: 1...11001100      |
| shr  | 오른쪽 시프트           | 13 shr 2(-13) shr 2   | 3: 0...00000011-4: 1...11111100        |
| ushr | 부호 없는 오른쪽 시프트 | 13 ushr 2(-13) ushr 2 | 3: 0...000000111073741820:001...111100 |
| and  | 비트 곱(AND)            | 13 and 19-13 and 19   | 1: 0...0000000119: 0...00010011        |
| or   | 비트 합(OR)             | 13 or 19-13 or 19     | 31: 0...00011111-13: 1...11110011      |
| xor  | 비트 배타합(XOR)        | 13 xor 19-13 xor 19   | 30: 0...00011110-32: 1...11100000      |
| inv  | 비트 반전(inversion)    | 13.inv()(-13).inv()   | -14: 1...1111001012: 0...00001100      |

```kotlin
13: 0...00001101
-13: 1...11110011
19: 0...00010011
```

### 2.5 문자 타입 Char

- Char 타입은 유니코드 한 글자를 표현하며 16비트다.
- 특수 문자를 위해 코틀린은 이스케이프(escape)를 제공한다.
- 임의의 유니코드 문자를 문자 리터럴에 넣을 수 있다.
  - `\\u` 다음에 네 자리 16진수 - `val pi = '\\u03C0' <- π를 의미한다`
- 코틀린은 Char 자체를 수 타입으로 취급하지는 않는다. 하지만 유니코드 문자 집합 내에서의 몇 가지 산술 연산을 허용한다.
  - +/- 연산자를 사용해 문자에 수를 더하거나 뺄 수 있다. 더하거나 뺀 수만큼 코드포인트가 이동한 새 문자를 반환한다.
  - 두 문자로 뺄셈을 하면 두 문자의 코드포인트 간 거리를 얻을 수 있다.
  - 문자를 ++ 또는 - -로 증가시키거나 감소시킬 수 있다(의미는 +나 -로 1을 더하거나 뺄 때와 같다).
- 코틀린에서 Char 연산은 Char를 결과로 돌려준다. (두 문자의 차이는 제외)

### 2.6 수 변환

- 각 수 타입마다 값을 다른 수 타입으로 변환하는 연산이 정의돼 있다.

  toByte(), toShort(), toInt(), toLong(), toFloat(), toDouble(), toChar()

- 코틀린에서는 범위가 큰 타입이 사용돼야 하는 문맥에 범위가 작은 타입을 쓸 수 없다.
 ex) Int 값을 Long 변수에 대입할 수 없다.

```kotlin
val n = 100      // Int
val l: Long = n  // 컴파일 오류 Error: can't assign Int to Long
```

  이렇게 하게 된 이유는  **암시적인 박싱 때문**이다. **일반적인 Int 값(또는 다른 수 타입의 값)이 꼭 원시 타입의 값으로 표현된다는 보장이 없다.** 따라서 방금 본 코드와 같은 더 큰 범위의 타입으로 변환하는 경우 다른 박싱한 타입의 값을 만들어낼 수 있는 가능성이 생기고, 이로 인해 **동등성(equality) 요구 조건을 만족시키지 못하게 되면서 미묘한 오류를 발생시킬 수 있다.** 위 코드를 올바른 코드로 인정하면 다음 연산이 false를 출력할 것이다.

  ```kotlin
  println(l == n) //실제 들어있는 값은 같지만 타입이 달라서... 동등성 결과가 예상과 다르다.
  ```

즉, 다음과 같은 코드에서도 에러가 발생한다.
```kt
val n = 100
val l : Long = 100
println(l == n) // Operator '==' cannot be applied to 'Long' and 'Int'
```

  하지만 이런 결과를 프로그래머가 예상하기는 힘들다.

- 정수 타입 사이의 변환은 대상 타입이 더 큰 범위를 담는 타입인 경우 손실 없이 수행된다. 그렇지 않은 경우 MSB(2진수로 표현했을 때 상위 비트 쪽)를 잘라내고 나머지를 대상 타입의 값으로 변환한다.

- 부동소수점 수 타입과 관련된 변환의 경우, 일반적으로 대상 타입과 무관하게 정밀도를 잃을 수 있다.

### 2.7 불 타입과 논리 연산

불이 지원하는 연산

- !: 논리 부정

- or, and, xor: **즉시 계산(eager) 방식**의 논리합, 논리곱, 논리배타합

  > 자바와 달리 코틀린은 &와 | 연산자를 제공하지 않는다. and와 or가 각각 &와 |를 대신한다.

- ||, &&: **지연 계산(lazy) 방식**의 논리합, 논리곱

즉시 계산인 and, or, xor은 이름 붙은 중위 연산자와 같은 우선순위이므로 && 연산이나 || 연산보다 더 우선해 계산된다.

```kotlin
// 예를 들어 다음 식은
a || b and c or d && e

// 다음과 같이 계산된다.
a || (((b and c) or d) && e)
```

### 2.8 비교와 동등성

- 코틀린은 두 인자가 **모두 같은 타입일 때**만 `==`와 `!=`를 허용한다.

  ```kotlin
  val a = 1                  // Int
  val b = 2L                 // Long
  println(a == b)            // 컴파일 에러 - Error: comparing Int and Long
  println(a.toLong() == b)   // Ok: 두 타입 모두 Long임
  ```

  값이 박싱돼 있는지에 따라 동등성 연산이 다른 결과를 낳을 수 있는데, 코틀린에서는 박싱이 암시적으로 진행되기 때문에 (자바 원시 타입에 해당하는 박싱이 될 수 있는 코틀린) 타입 사이의 동등성 연산을 허용하면 혼란을 야기할 수 있기 때문이다. → 아예 컴파일단계에서 허용하지 않음

- 하지만 모든 수 타입의 값은 서로 <, <=, >, >=를 사용해 비교할 수 있다.

  ```kotlin
  1 <= 2L || 3 > 4.5
  ```

- Char와 Boolean 값도 비교 연산을 지원한다. (같은 타입의 값과만 비교 가능)

  ```kotlin
  false == true // false
  false < true  // true                    //false가 true보다 작다고 가정
  false > 1     // Error: comparing Boolean and Int
  'a' < 'b'     // true                    //Char는 문자의 코드 값에 따라 비교된다
  'a' > 0       // Error: comparing Int and Char
  ```

- 부동소수점 타입 비교 연산은 IEEE 754 표준을 따른다.

- 기본적으로 NaN은 그 어떤 값과도 같지 않다.

  특히 다른 NaN과도 같지 않고, 무한대를 포함한 다른 어떤 값보다 작지도 않고 크지도 않다.

  하지만 이 규칙은 컴파일러가 정적으로 관심 대상의 타입이 부동소수점 타입이라는 사실을 알 때만 적용된다. 예를 들어 수를 컬렉션(collection)에 넣는 것과 같은 경우에는 컴파일러가 동등성 연산자를 사용해 박싱한 타입을 처리하는 규칙을 사용한다. JVM에서 이는 원시 타입의 값을 감싼 Double과 Float 래퍼 타입의 인스턴스를 비교한다는 뜻이다.

- NaN은 자기 자신과 같다. 집합에 NaN이 단 하나만 추가됐기 때문이다.

- NaN은 Double에서 가장 큰 값으로 취급된다(심지어 양의 무한대보다도 크다).

  ```kotlin
  println(Double.NaN == Double.NaN)              // false
  println(Double.NaN != Double.NaN)              // true
  println(Double.NaN <= Double.NaN)              // false
  println(Double.NaN < Double.POSITIVE_INFINITY) // false
  println(Double.NaN > Double.NEGATIVE_INFINITY) // false
  
  val set = sortedSetOf(Double.NaN, Double.NaN,Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,0.0)
  println(set) // [-Infinity, 0.0, Infinity, NaN]
  ```

## 2.3 문자열

- 코틀린 문자열도 불변

### 3.1 문자열 템플릿

- 특수 문자가 들어가면 이스케이스(`\\`) 시퀀스를 사용
- `${}` 안에 식을 넣어서 문자열을 만들 수 있다.
- 큰따옴표(`”””`)를 사용해 로우 문자열(raw string)을 만들면 이스케이프 시퀀스를 사용하지 않고도 문자열을 작성할 수 있다.

```kotlin
val text = "Hello, world!\\nThis is \\"multiline\\" string"
println("\\u03C0 \\u2248 3.14") // π ≈ 3.14
println("Hello, $name!\\n Today is ${Date()}")

val message = """
  Hello, $name!
  Today is ${Date()}
""".trimIndent()
```

- trimIndent() : 여러 줄에 공통된 최소 들여쓰기(indent)를 제거해주는 표준 코틀린 함수

### 3.2 기본 문자열 연산

모든 String 인스턴스는 다음 프로퍼티를 제공한다.

- length : 문자열에 든 문자 수를 표현
- lastIndex : 문자열의 마지막 문자 인덱스를 표현

```kotlin
"Hello!".length      // 6
"Hello!".lastIndex   // 5(첫 번째 문자의 인덱스가 0이므로)
```

- `+` 연산자를 사용해 두 문자열을 연결할 수 있다.

- 문자열은 `==`와 `!=`를 사용해 동등성을 비교할 수 있다.

  > 코틀린에서는 ==가 기본적으로 equals()를 가리키는 편의 문법(syntatic sugar)이기 때문에 ==를 사용하면 직접 equals()를 호출하므로, 따로 equals()를 호출할 필요가 없다.

- 코틀린에서는 `===`, `!==` 연산자를 사용해 참조 동등성을 비교할 수 있다.

```kotlin
val s1 = "Hello!"
val s2 = "Hel" + "lo!"
println(s1 == s2) // true
```

- 문자열은 수 타입이나 불로 변환하는 toByte(), toShort(), toInt(), toLong(), toFloat(), toDouble(), toBoolean() 변환 함수를 제공

## 2.4 배열

### 4.1 배열 정의하기

배열 생성하기

```kotlin
val a = emptyArray<String>()        // Array<String> (원소 0개)
val b = arrayOf("hello", "world")   // Array<String> (원소 두 개)
val c = arrayOf(1, 4, 9)            // Array<Int> (원소 세 개)

//인덱스로부터 원소를 생성 - 인덱스를 기반으로 값을 계산하는 람다식을 정의한다.
val squares = Array(3) { (it + 1)*(it + 1) } // [1,3,9]
```

- `Array<Int>`를 사용하는 배열은 모든 수를 박싱하기 때문에 실용적이지 못하다.

  코틀린은 더 효율적인 ByteArray, ShortArray, IntArray, LongArray, FloatArray, DoubleArray, CharArray, BooleanArray라는 **특화된 배열 타입**을 제공한다.

  JVM에서 이런 배열 타입들은 int[], boolean[] 등의 원시 타입 배열로 표현된다. 이런 특화된 배열에도 arrayOf()나 Array()에 해당하는 함수가 함께 따라온다.

```kotlin
val operations = charArrayOf('+', '-', '*', '/', '%')
val squares = IntArray(10) { (it + 1)*(it + 1) }
```

### 4.2 배열 사용하기

- size : 배열의 크기
- lastIndex : 배열의 마지막 요소 인덱스를 표현

```kotlin
val squares = arrayOf(1, 4, 9, 16)
squares.size       // 4
squares.lastIndex  // 3
squares[3]         // 16
squares[2] = 100 // squares: 1, 4, 100, 16
squares[0]--     // squares: 0, 4, 100, 25
```

- 배열 타입의 변수 자체에는 실제 데이터에 대한 **참조를 저장**한다.

  이로 인해 배열 변수에 다른 배열을 대입하면 같은 데이터 집합을 함께 공유하게 된다.

```kotlin
val numbers = squares
numbers[0] = 1000     // 바뀐 데이터가 squares와 numbers에 공유됨
println(squares[0])   // prints 1000
```

- copyOf() : 원본과 별도의 배열을 생성

```kotlin
val numbers = squares.copyOf()
numbers[0] = 1000   // squares에는 영향이 없다
squares.copyOf(2)   // 뒤가 잘림: 1, 4
squares.copyOf(5)   // 부족한 부분에 0이 채워짐: 1, 4, 9, 16, 0
```

- 자바에서는 상위 타입의 배열에 하위 타입의 배열을 대입할 수 있었다. 배열이 가변 데이터 구조이므로 이런 대입은 런타임 시 문제를 발생시킬 수 있다.

```kotlin
Object[] objects = new String[] { "one", "two", "three" };
objects[0] = new Object(); // ArrayStoreException 예외가 발생함
```

이런 이유로 코**틀린 배열 타입은 (자신과 같은 타입을 제외하고) 모든 다른 배열 타입과 서로 하위 타입 관계가 성립하지 않는다고 간주되며, 이에 따라 앞에서 본 것 같은 대입도 금지된다.** **코틀린에서 String은 Any의 하위 타입이지만 Array<String>은 Array<Any>의 하위 타입이 아니다.**

```kotlin
val strings = arrayOf("one", "two", "three")
val objects: Array<Any> = strings // 예외
```

- `+` 연산 : 원소를 추가한 새로운 배열을 생성

```kotlin
val b = intArrayOf(1, 2, 3) + 4               // 원소를 하나만 추가: 1, 2, 3, 4
val c = intArrayOf(1, 2, 3) + intArrayOf(5, 6)// 다른 배열을 추가: 1, 2, 3, 5, 6
```

- `==`, `!=` : 원소 자체를 비교하지 않고 참조를 비교 (문자열과 다름)
- `contentEquals()` : 배열 내용을 비교