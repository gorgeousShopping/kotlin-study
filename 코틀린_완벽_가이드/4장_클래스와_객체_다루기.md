# 4장. 클래스와 객체 다루기

## 4.1 클래스 정의하기

* 클래스 정의는 커스텀으로 정의된 연산들이 포함된 새로운 타입을 만들어준다. 

* 기본적으로 클래스 선언은 **참조 타입**(referential type)을 정의한다. 즉, 이런 참조 타입의 값은 특정 클래스 인스턴스의 실제 데이터 위치를 가리키는 참조다. 
* 코틀린 1.3부터는 **인라인 클래스**(inline class)라는 개념이 도입됐다. 인라인 클래스를 사용하면 **참조 타입이 아닌 타입을 정의**할 수 있다. 

### 4.1.1 클래스 내부 구조

* class 키워드 다음에 클래스 이름이 오고 그다음에 클래스 본문이 오는 형태로 정의

  ```kotlin
  class Person {
      var firstName: String = ""
      var familyName: String = ""
      var age: Int = 0
  
      fun fullName() = "$firstName $familyName"
  
      fun showMe() {
          println("${fullName()}: $age")
      }
  }
  ```

위 코드는 모든 Person 클래스의 인스턴스마다 firstName, familyName, age라는 프로퍼티와 fullName() 및 showMe()라는 두 함수가 들어있게 된다.

* 여러 가지 프로퍼티 유형 중 가장 단순한 것은 그냥 **특정 클래스와 연관된 변수**다. 자바 클래스 필드와 비슷하게 생각될 수도 있으며, 더 일반적인 경우에는 **프로퍼티에 어떤 계산이 포함될 수 있다.**

  이럴 경우에는 클래스 인스턴스 내부에 저장되는 대신 그때그때 계산되거나 지연 계산되거나 맵(map)에서 값을 얻어오는 등의 방식으로 프로퍼티의 값을 제공할 수 있다.

* 모든 프로퍼티에서 일반적으로 쓸 수 있는 기능에는 다음과 같이 마치 변수처럼 프로퍼티를 사용하는 참조 구문이 있다.

  ```kotlin
  fun showAge(p: Person) = println(p.age) //프로퍼티 읽기
  fun readAge(p: Person) {
      p.age = readLine()!!.toInt() //프로퍼티에 쓰기
  }
  ```

* 프로퍼티는 어떤 클래스의 **구체적인 인스턴스**(위 코드에서 p가 이런 인스턴스)와 엮여 있기 때문에 이 인스턴스를 식으로 지정해야 한다. 이런 인스턴스를 **수신 객체(receiver)**라 부르고, 수신 객체는 프로퍼티에 접근할 때 사용해야 하는 객체를 지정한다. 
* 멤버 함수의 경우에도 똑같이 수신 객체가 있고, 이런 경우 멤버 함수를 **메서드(method)**라 부른다.

* 클래스 내부에서는 `this` 식으로 수신 객체를 참조할 수 있다. 

  대부분의 경우 this를 디폴트로 가정하기 때문에 수신 객체의 멤버 안에서 수신 객체의 멤버를 참조할 때는 this를 생략해도 된다. 

  ```kotlin
  class Person {
      var firstName: String = ""
      var familyName: String = ""
      var age: Int = 0

      fun fullName() = "${this.firstName} ${this.familyName}" //this 생략가능

      fun showMe() {
          println("${this.fullName()}: ${this.age}")
      }

  }
  ```

* this가 꼭 필요한 경우도 있다.

  예를 들어 어떤 클래스의 프로퍼티와 메서드 파라미터 이름이 같은 경우, 이 둘을 구분하기 위해 프로퍼티 이름 앞에 this를 써야 한다.

  ```kotlin
  class Person {
      var firstName: String = ""
      var familyName: String = ""

      fun setName(firstName: String, familyName: String) {
          this.firstName = firstName //프로퍼티에 this를 붙여서 파라미터와 구분
          this.familyName = familyName
      }
  }
  ```

* 인스턴스 생성 시 new 키워드가 필요없다. 함수를 사용하듯 그냥 클래스 이름을 이용한다.

  ```kotlin
  val person = Person()
  ```

* 기본적으로 코틀린 클래스는 공개(`public`) 가시성이다. 코드의 어느 부분에서나 클래스를 사용할 수 있다.
* 최상위 함수와 마찬가지로 최상위 클래스를 `internal`이나 `private`으로 설정할 수 있다. 이렇게 지정하면 클래스의 가시성 범위를 클래스 정의가 들어있는 파일 내부나 컴파일 모듈 내부로 제한할 수 있다.

* 코틀린에서는 소스 파일의 이름을 그 안에 들어있는 공개 클래스 이름과 똑같이 만들 필요가 없다. 한 파일 안에 여러 공개 클래스를 넣을 수도 있다.
* 클래스 프로퍼티는 지역 변수와 마찬가지로 불변일 수 있다. 하지만 이런 경우 초기화를 하는 동안 프로퍼티의 값을 지정할 수단이 있어야 한다. 그렇지 않다면 모든 클래스가 같은 프로퍼티 값을 사용하게 된다. 커스텀 생성자를 사용하여 해결할 수 있다.

  ```kotlin
  class Person {
    // 생성자로 초기화할 방법이 없으면 모든 클래스가 
    // firstName에 대해 같은 값을 사용하게 됨
    val firstName = "John"
  }
  ```



#### 들여다보기 - 필드와 프로퍼티 (cf. 다재다능 코틀린 프로그래밍 책)

자바 필드와 달리, 코틀린에서는 클라이언트 코드를 바꾸지 않아도 **원하는 대로 프로퍼티의 구현을 바꿀 수 있기 때문에**(예를 들어 커스텀 게터나 세터를 추가해도 클라이언트 소스코드를 바꿀 필요가 없다) **코틀린 프로퍼티는 캡슐화(encapsulation)에 위배되지 않는다.** 즉, firstName이라는 **참조는 프로퍼티가 구현되는 방법과 무관하게 항상 올바른 참조로 남을 수 있다.** 프로퍼티가 사용하는 내부 필드는 항상 캡슐화돼 있고 클래스 정의 밖에서는 이 내부 필드에 접근할 수 없다. 사실은 프로퍼티 정의 자체가 아니면 이런 내부 필드에 접근할 방법이 없다.



```kotlin
// Car.kt
class Car(val yearOfMake: Int, var color: String)
```

* 위 예제의 `yearOfMake`, `color` 은 (Java의 관점에서 봤을 때 속성이라기보다는 필드에 가깝다. 하지만) **모두 필드가 아니고 속성이다. 코틀린에서는 클래스에 필드가 없다.**

- 코틀린에선 getter, setter 대신 속성의 이름을 이용해서 속성에 접근할 수 있다.
- `car.yearOfMake` 를 호출하면 실제로는 `car.getYearOfMake()`를 호출한 것이다. (자바에서 처럼 직접 필드에 접근할 수 없다.)

컴파일러는 JavaBean 컨벤션을 존중한다. 코틀린 컴파일러로 바이트코드를 생성하는 실험을 해보자

1. javap 툴을 이용해서 앞서 만든 Car.kt 코드를 컴파일하고 바이트코드를 살펴보자

   ```kotlin
   kotlinc-jvm Car.kt //Car.class 파일을 만들어준다. (package가 있다면 package 하위 경로에)
   javap -p Car.calss //class 파일 디셈블러
   ```

   > `javap` 커맨드 : 자바 클래스 파일 역어셈블러 어떤 바이트코드 파일이 어디서부터 나왔으며, 어떠한 필드와 메소드를 갖고 있는 파일인지를 알려주는 기능

   ![image-20221218173038622](../images/image-20221218173038622.png)

2. 코틀린 컴파일러가 생성한 Car 클래스의 바이트코드이다.

   ```kotlin
    javap -p Car.class
   Compiled from "Car.kt"
   public final class ch07.Car {
     **private final int yearOfMake; //백킹필드
     private java.lang.String color; //백킹필드 - private으로 자바에서 필드에 직접 접근할 수 없다.**
     public ch07.Car(int, java.lang.String); //생성자
     public final int getYearOfMake(); //getter
     public final java.lang.String getColor(); //getter
     public final void setColor(java.lang.String); //setter
   }
   ```

   Car 클래스 한줄의 코드를 코틀린 코드가 속성을 위한 두 개의 백킹 필드(backing field), 생성자, 두 개의 getter, 하나의 setter로 바뀌었다.

* 자바는 필드가 없거나 필드 이름이 'aaa'여도 `getName()`, `setName()` 이라는 게터, 세터가 있으면,  `getName()`, `setName()` 가 **프로퍼티**가 된다. 이 때 사용되는 필드인 'aaa'가 백킹 필드라고 한다. 즉, 프로퍼티는 메서드를 가지고 정의가 된다. 

  → 앞서 "코틀린의 프로퍼티 참조는 프로퍼티가 구현되는 방법과 무관하게 항상 올바른 참조로 남을 수 있다."라는 문구에서 올바르지 않은 참조가 되는 경우가 이해되지 않았었는데 자바에서는 `getName()`, `setName()` 이라는 게터, 세터에서 'aaa'라는 백킹필드가 아닌 'bbb'라는 백킹필드를 사용하도록 수정해버리면 'aaa'에 대한 참조가 올바르지 않게되는 상황을 말하는 것으로 이해했다.

* 코틀린에서 백킹필드가 결국 자바에서 필드가 된다. (게터에서 사용되는 필드) → 코들린에서 `field` 라는 키워드로 필드에 접근할 수 있다.

> [Field vs Properties 차이](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=saga111&logNo=120015999769)



### 4.1.2 생성자

* 생성자 - 클래스 인스턴스를 초기화해주고 인스턴스 생성 시 호출되는 특별한 함수

  ```kotlin
    class Person(firstName: String, familyName: String) {
      val fullName = "$firstName $familyName"
  }
  
  fun main() {
      val person = Person("승우", "조") // 새 Person 인스턴스 생성
      println(person.fullName) //승우 조
  }
  ```

class 키워드 이름 뒤에 덧붙인 파라미터 목록이 클래스의 인스턴스를 생성할 때 클래스에 전달된다. 이 파라미터를 사용해 프로퍼티를 초기화한다.

* 클래스 헤더의 파라미터 목록을 **주생성자(primary constructor) 선언**이라고 부른다. 

* 주생성자는 함수와 달리 본문이 하나가 아니다.

  대신 주생성자는 클래스 정의 내에서 **프로퍼티 초기화**와 **초기화 블록**이 등장하는 순서대로 구성된다. 

* **초기화 블록**이란 **`init`이라는 키워드가 앞에 붙은 블록**이다. 이 블록 안에서 클래스 초기화 시 필요한 간단하지 않은 초기화 로직을 수행할 수 있다.

  예를 들어 다음 클래스는 주생성자가 호출될 때마다 메시지를 표시한다.

  ```kotlin
  class Person(firstName: String, familyName: String) {
    val fullName = "$firstName $familyName"  //1. 프로퍼티 초기화
    
    init { //2. 초기화 블록
      println("Created new Person instance: $fullName")
    }
  }
  ```

* 클래스 안에 init 블록이 여럿 들어갈 수 있다. 이런 경우 각 블록은 프로퍼티 초기화와 함께 순서대로 실행된다.

  **초기화 블록에는 return 문이 들어가지 못한다**는 점에 유의하자.

  ```kotlin
  class Person(firstName: String, familyName: String) {
    val fullName = "$firstName $familyName"
    
    init {
      if (firstName.isEmpty() && familyName.isEmpty()) return // error - 리턴문이 있으면 안됨
      println("Created new Person instance: $fullName")
    }
  }
  ```

* 프로퍼티 값을 프로퍼티 정의 시 초기화하지 않고 `init`블록 안에서 복잡한 초기화 로직을 실행해서 프로퍼티를 초기화할 수 있다.

  ```kotlin
  class Person(fullName: String) {
      val firstName: String
      val familyName: String
      init {
          val names = fullName.split(" ")
          if (names.size != 2) {
              throw IllegalArgumentException("Invalid name: $fullName")
          }
          firstName = names[0] //초기화 블록으로 프로퍼티를 초기화
          familyName = names[1]
      }
  }
  
  fun main() {
      val person = Person("승우 조")
      println(person.firstName) //승우
  }
  ```


* 컴파일러는 모든 프로퍼티가 확실히 초기화되는지 확인한다. 

  컴파일러가 주생성자의 모든 실행 경로가 모든 멤버 프로퍼티를 초기화하거나 (일부 프로퍼티가 초기화되지 않는 경우) 예외를 발생시키는지 확인할 수 없다면 다음과 같은 오류가 발생한다.

  ```kotlin
  class Person(fullName: String) {
    // error: property must be initialized or be abstract
    val firstName: String
    val familyName: String
    init {
      val names = fullName.split(" ")
      if (names.size == 2) { //이 외의 경우의 수에 대한 초기화로직이 없어서 에러가 발생
        firstName = names[0]
        familyName = names[1]
      }
    }
  }
  ```

* **주생성자 파라미터를 프로퍼티 초기화나 init 블록 밖에서 사용할 수는 없다.** 

  예를 들어 멤버 함수 내부에서는 firstName을 사용할 수 없기 때문에 다음 코드는 잘못된 코드다.

  ```kotlin
  class Person(firstName: String, familyName: String) {
    val fullName = "$firstName $familyName"
    fun printFirstName() {
      println(firstName) // Error: 주생성자 파라미터 firstName을 여기서 사용할 수 없다.
    }
  }
  ```

  이에 대한 해법

  1. (방법1) 생성자 파라미터의 값을 저장할 멤버 프로퍼티를 정의한다.

     ```kotlin
     class Person(firstName: String, familyName: String) {
       val firstName = firstName // firstName은 생성자 파라미터를 가리킴
       val fullName = "$firstName $familyName"
       fun printFirstName() {
         println(firstName) // Ok: 여기서 firstName은 멤버 프로퍼티를 가리킴
       }
     }
     ```

  2. (방법2) 생성자 파라미터의 값을 멤버 프로퍼티로 만든다.

     생성자 파라미터 앞에 `val`이나 `var` 키워드를 덧붙이면, **자동으로 해당 생성자 파라미터로 초기화되는 (생성자 파라미터와 이름이 같은) 프로퍼티를 정의한다.** 이때 파라미터 이름을 프로퍼티 초기화나 init 블록 안에서 참조하면 생성자 파라미터를 가리키고, 다른 위치에서 참조하면 프로퍼티를 가리키게 된다.

     ```kotlin
     class Person(val firstName: String, familyName: String) {
       val fullName = "$firstName $familyName" // firstName은 생성자 파라미터를 가리킴
       
       fun printFirstName() {
         println(firstName) // firstName은 멤버 프로퍼티를 가리킴
       }
     }
     
     fun main() {
       val person = Person("승우", "조")
       println(person.firstName) // firstName은 프로퍼티를 가리킴
     }
     ```

* `val`/`var` 파라미터를 사용하면 단순하지 않은 멤버가 포함되지만 본문은 비어있는 클래스를 정의할 수 있다.

  이런 경우 코틀린에서는 본문을 아예 생략할 수 있다. 이런 코딩 스타일을 권장한다.

  ```kotlin
  class Person(val firstName: String, val familyName: String = "") {
  }
  ```

* 함수와 마찬가지로 **디폴트 값**과 **vararg**를 생성자 파라미터에 사용할 수 있다.

  ```kotlin
  class Person(val firstName: String, val familyName: String = "") { //디폴트값 지정
    fun fullName() = "$firstName $familyName"
  }
  
  class Room(vararg val persons: Person) { //vararg 사용하여 여러개를 받을 수 있다.
    fun showNames() {
      for (person in persons) println(person.fullName())
    }
  }
  
  fun main() {
    val room = Room(Person("Solar"), Person("Solar", "Kim"))
    room.showNames()
  }
  ```

### 부생성자

* 여러 생성자를 사용해 클래스 인스턴스를 서로 다른 방법으로 초기화하고 싶을 경우, **부생성자(secondary constructor)**를 사용할 수 있다.

  * **`constructor` 키워드**를 사용
  * 부생성자에 반환 타입을 지정할 수는 없지만, 기본적으로 부생성자는 Unit 타입 값을 반환하는 함수와 마찬가지 형태다. 
  * 특히 (init 블록과 달리) **부생성자 안에서는 return을 사용할 수 있다.**

  ```kotlin
  class Person {
    val firstName: String
    val familyName: String
    
    constructor(firstName: String, familyName: String) { //부생성자1
      this.firstName = firstName
      this.familyName = familyName
    }
    
    constructor(fullName: String) { //부생성자2
      val names = fullName.split(" ")
      if (names.size != 2) {
        throw IllegalArgumentException("Invalid name: $fullName")
      }
      firstName = names[0]
      familyName = names[1]
    }
  }

* 클래스에 주생성자를 선언하지 않은 경우

  1. **모든 부생성자는 자신의 본문을 실행하기 전에 프로퍼티 초기화와 init 블록을 실행한다.** 

     **이렇게 하면 어떤 부생성자를 호출하든지 공통적인 초기화 코드가 정확히 한 번만 실행되게 보장할 수 있다.**

  2. 부생성자가 **생성자 위임 호출**을 사용해 다른 부생성자를 호출하는 방법도 있다.

     생성자 파라미터 목록 뒤에 **콜론(:)**을 넣고 그 뒤에 일반 함수를 호출하는 것처럼 코드를 작성하되, 함수 이름 대신 **this**를 사용하면 생성자 위임 호출이 된다.

     ```kotlin
     class Person {
       val fullName: String
       constructor(firstName: String, familyName: String):
         this("$firstName $familyName") //생성자 위임 호출
       constructor(fullName: String) {
         this.fullName = fullName
       }
     }
     ```

* 클래스에 주생성자가 있는 경우

  * (부생성자가 있는 경우) **모든 부생성자는 주생성자에게 위임을 하거나 다른 부생성자에게 위임을 해야 한다.** 

    예를 들어 앞의 예제에서 두 번째 생성자를 주생성자로 바꿀 수 있다.

    ```kotlin
    class Person(val fullName: String) {
      constructor(firstName: String, familyName: String):
        this("$firstName $familyName") //주생성자에게 위임
    }
    ```

* **부생성자의 파라미터 목록에는 val/var 키워드를 쓸 수 없다.**

  ```kotlin
  class Person {
    // error: 'val' on secondary constructor parameter is not allowed 
    constructor(val fullName: String) 
  }
  ```

> 부생성자와 클래스 상속이 결합되는 경우, 상위 클래스 생성자를 호출하는 것과 관련된 다른 문제가 있다. 이에 대해서는 **8장 클래스 계층 이해하기**에서 살펴본다.



### 4.1.3 멤버 가시성

* 가시성은 클래스 멤버마다 다르게 지정할 수 있다.

* **public(공개)** : 멤버를 어디서나 볼 수 있다. 디폴트 가시성이 바로 public이다. 따라서 명시적으로 public을 표기할 필요가 없다.
* **internal(모듈 내부)** : 멤버를 멤버가 속한 클래스가 포함된 컴파일 모듈 내부에서만 볼 수 있다.
* **protected(보호)** : 멤버를 멤버가 속한 클래스와 멤버가 속한 클래스의 모든 하위 클래스 안에서 볼 수 있다.
* **private(비공개)** : 멤버를 멤버가 속한 클래스 내부에서만 볼 수 있다.

> 코틀린과 달리, 자바의 기본 가시성은 **패키지 전용(package parivate)**으로, 어떤 멤버를 이 멤버가 속한 클래스가 들어있는 패키지 내부로 제한된다. 자바에서 (어떤 정의를 어느 곳에서나 쓸 수 있게) 클래스 멤버를 공개 멤버로 정의하려면 명시적으로 **public 변경자를 정의 앞에 붙여야 한다.** 코틀린에는 자바의 패키지 전용에 해당하는 가시성이 없다

* 함수와 프로퍼티, 주생성자, 부생성자에 대해 가시성 변경자를 지원한다. 

  함수와 프로퍼티, 주생성자/부생성자는 모두 클래스 본문에 정의되거나 주생성자 파라미터로 정의된다. 

* 주생성자의 가시성을 지정하려면 constructor 키워드를 꼭 명시해야 한다.

  ```kotlin
  class Empty private constructor() { //주생성자를 private으로 설정
    fun showMe() = println("Empty")
  }
  
  fun main() {
    // error: cannot access '<init>': it is private in 'Empty'
    Empty().showMe() //Empty의 주생성자를 찾을 수 없다.
  }
  ```

  Empty 클래스의 유일한 생성자가 private이므로 이 클래스를 클래스 본문 외부에서 인스턴스화 할 수 없다. 

동반 객체(companion object)에서 팩토리 메서드(factory method)를 제공할 때 생성자를 감추는 방법을 어떻게 함께 조합할지 알아보자.



### 4.1.4 내포된 클래스(nested class)

* 코틀린 클래스는 다른 클래스도 멤버로 가질 수 있다. 이런 클래스를 내포된 클래스(nested class)라고 부른다. 

```kotlin
class Person (val id: Id, val age: Int) {
    class Id(val firstName: String, val familyName: String) //내포된 클래스
    fun showMe() = println("${id.firstName} ${id.familyName}, $age")
}

fun main() {
    val id = Person6.Id("Solar", "Kim")
    val person = Person(id, 25)
    person.showMe() //Solar Kim, 25
}
```

* 내포된 클래스를 둘러싸고 있는 클래스의 본문 밖에서는 Person.Id처럼 **내포된 클래스 이름 앞에 바깥쪽 클래스의 이름을 덧붙여야만 내포된 클래스를 참조할 수 있다.**

* 내포된 클래스에도 여러 가지 가시성을 지정할 수 있다.

  내포된 클래스도 자신을 둘러싼 클래스의 멤버이므로 자신을 포함하는 클래스의 비공개 선언에 접근할 수 있다.

```kotlin
class Person (private val id: Id, private val age: Int) {
  class Id(private val firstName: String,
           private val familyName: String) {
    fun nameSake(person: Person) = person.id.firstName == firstName
  }

  fun showMe() = println("${id.firstName} ${id.familyName}, $age") // error: cannot access 'familyName': it is private in 'Id'
}
```

* 자바와 달리, **바깥쪽 클래스는 자신에게 내포된 클래스의 비공개 멤버에 접근할 수 없다.**

* **내포된 클래스에 `inner`를 붙이면 자신을 둘러싼 외부 클래스의 현재 인스턴스에 접근할 수 있다.** → 내부 클래스가 된다.

```kotlin
class Person(val firstName: String, val familyName: String) {
  inner class Possession(val description: String) { //inner 키워드 -> 내부 클래스로 만든다.
    fun showOwner() = println(fullName())
  }
  
  val myChocolate = Possession("Dark Chocolate") //this.Possession("Dark Chocolate")와 동일
  private fun fullName() = "$firstName $familyName"
}

fun main() {
  val person = Person("Solar", "Kim")
  val wallet = person.Possession("Wallet") // Possession 생성자 호출. 외부 클래스 인스턴스(person)를 지정해야한다.
  wallet.showOwner() // Solar Kim
  println(person7.myChocolate.description) //Dark Chocolate
}
```

* **내부(inner)클래스 생성자를 호출할 때 외부 클래스 인스턴스를 지정해야 한다.**

* 내부 클래스를 가리킬 때도 this를 생략할 수 있다.

* 일반적으로 `this`는 항상 **가장 내부의 클래스 인스턴스**를 가리킨다. 따라서 내부 클래스 본문에서 this는 내부 클래스 자신을 가리킨다. 내부 클래스 본문에서 **외부 클래스 인스턴스를 가리켜야 한다면 한정시킨(qualified) this 식을 사용해야 한다.**

  * 한정시킨 `this` 식에서 `@` 기호 다음에 오는 식별자는 외부 클래스의 이름이다.

  ```kotlin
  class Person(val firstName: String, val familyName: String) {
    inner class Possession(val description: String) {
      fun getOwner() = this@Person //한정시킨 this@외부클래스명
    }
  }
  
  fun main() {
      val person = Person("쟈니", "서")
      val wallet = person.Possession("Wallet")
      println(wallet.getOwner().firstName) // 쟈니
  }



#### 내부(inner) 클래스 vs 중첩(nested) 클래스

내포된 클래스와 달리 **내부 클래스에는 반드시 자신과 연관된 외부 클래스 인스턴스가 있어야 한다.** 내부 클래스가 외부 클래스의 멤버에 접근할 수 있는 이유는 항상 자신과 연관된 외부 클래스 인스턴스가 있기 때문이다. 이를 내부 클래스 안에 컴파일러가 자동으로 정의해주는 외부 클래스 인스턴스를 가리키는 outer 같은 프로퍼티가 있는 것처럼 생각할 수 있다.

```kotlin
// nested class 중첩 클래스
class Outer {
    private val bar: Int = 1
    class Nested {
        fun foo() = 2
    }
}

val demo = Outer.Nested().foo() // == 2 (외부클래스를 참조하지 않음)
```

```kotlin
// inner class 내부 클래스
class Outer {
    private val bar: Int = 1
    inner class Inner {
        fun foo() = bar
    }
}

val demo = Outer().Inner().foo() // == 1 외부클래스를 항상 참조
```

|        | 내부(inner) 클래스  | 중첩(nested) 클래스  |
| ------ | ------------------- | -------------------- |
| 코틀린 | inner 키워드로 선언 | 기본                 |
| 자바   | 기본                | static 키워드로 선언 |



### 4.1.5 지역 클래스

* 함수 본문에서 클래스를 정의할 수 있다. 지역 클래스는 자신을 둘러싼 코드 블록 안에서만 쓰일 수 있다.

```kotlin
fun main() {
  class Point(val x: Int, val y: Int) {
    fun shift(dx: Int, dy: Int): Point = Point(x + dx, y + dy)
    override fun toString() = "($x, $y)"
  }
  val p = Point(10, 10)
  println(p.shift(-1, 3)) // (9, 13)
}

fun foo() {
  println(Point(0, 0)) // error. Point는 main함수 안에서만 쓰일 수 있다.
}
```

* 코틀린 지역 클래스도 자신을 둘러싼 코드의 선언에 접근할 수 있다. 특히 지역 클래스는 클래스 본문 안에서 자신이 접근할 수 있는 값을 포획(capture)할 수 있고, 심지어는 변경할 수도 있다.

```kotlin
fun main() {
  var x = 1
  
  class Counter {
    fun increment() {
      x++
    }
  }
  
  Counter().increment()
  
  println(x) // 2
}
```

> 코틀린과 달리 자바에서는 포획한 변수의 값을 변경할 수 없다. 더 나아가 익명 클래스 내부에서 포획한 변수를 사용할 경우에는 명시적으로 final로 선언해야만 한다. 하지만 코틀린이 제공하는 포획 변수를 변경하는 기능은 그에 따른 비용을 수반한다. 익명 객체와 이 객체를 둘러싸고 있는 코드 사이에 변수를 공유하기 위해 코틀린 컴파일러는 (공유되는) 값을 특별한 래퍼(wrapper) 객체로 둘러싼다. 위 Counter 예제를 컴파일한 바이트코드에 해당하는 자바 코드는 다음과 같다.

```java
import kotlin.jvm.internal.Ref.IntRef;

class MainKt {
  public static void main(String[] args) {
    final IntRef x = new IntRef(); // 래퍼 생성
    x.element = 1;
    
    final class Counter {
      public final void increment() {
        x.element++; // 공유된 데이터 변경하기
      }
    }
    
    (new Counter()).increment();
    
    System.out.println(x.element); // 공유된 데이터 읽기
  }
}
```

> 불변 변수는 값이 바뀌지 않기 때문에 래퍼가 필요 없으므로 이런 부가 비용이 없다.

* 가시성 변경자를 붙일 수 없다. 
* 함수, 프로퍼티, 생성자, 내포된 클래스 등 다른 클래스가 포함할 수 있는 모든 멤버를 포함할 수 있다. 하지만 내포된 클래스는 가시성 규칙을 혼동시키지 않기위해 반드시 inner 클래스여야만 한다.



## 4.2 널 가능성



### 4.2.1 널이 될 수 있는 타입



### 4.2.2 널 가능성과 스마트 캐스트





### 4.2.3 널 아님 단언 연산자







### 4.2.4 안전한 호출 연산자





### 4.2.5 엘비스 연산자













## 4.3 단순한 변수 이상인 프로퍼티











## 4.4 객체











