- [함수 정의하기](#함수-정의하기)
  - [3.1 함수](#31-함수)
    - [3.1.1 코틀린 함수의 구조](#311-코틀린-함수의-구조)
    - [3.1.2 위치 기반 인자와 이름 붙은 인자](#312-위치-기반-인자와-이름-붙은-인자)
    - [3.1.3 오버로딩과 디폴트 값](#313-오버로딩과-디폴트-값)
    - [vararg](#vararg)
  - [3.2 패키지와 임포트](#32-패키지와-임포트)
  - [3.3 조건문](#33-조건문)
  - [3.4 루프](#34-루프)
  - [3.5 예외처리](#35-예외처리)
  - [3.6 결론](#36-결론)

---

# 함수 정의하기

## 3.1 함수

### 3.1.1 코틀린 함수의 구조

```kt
import kotlin.math.PI

fun main() {
    print("Enter radius: ")
    val radius = readLine()!!.toDouble()
    println("Circle area: ${circleArea(radius)}")
}

fun circleArea(radius: Double): Double {
    return PI * radius * radius
}
````


- `fun` 키워드는 컴파일러에게 함수 정의가 뒤따라 온다는 사실을 알려준다.
- 변수 이름과 마찬가지로 아무 식별자나 함수 이름으로 쓸 수 있다.
- 파라미터(파라미터를 받지 않는다고 하더라도, 파라미터를 감싸는 괄호는 꼭 있어야 한다.)
- 반환 타입 ( 함수명 옆 `:Type`)
- 함수 본문 (`{}`)

> 자바 vs 코틀린

- 자바 메서드 파라미터는 디폴트가 가변이므로, 함수 내부에서 변경하지 못하게 하려면 `final` 키워드를 통해 불변 값으로 바꿔야 하는데, **코틀린 함수 파라미터는 무조건 불변**이다.
- 그 말인 즉, 함수 본문에서 파라미터 값을 변경하려고 시도하면 컴파일 오류가 발생한다.

```kt
fun increment(n: Int): Int{
    return n++ // 에러가 발생한다! 
}
```

- 또한, 코틀린에서는 파라미터 앞에 `val` 이나, `var` 를 표시할 수 없다는 점에 유의하자.
  - 이와 같이 강제하는 이유는, **파라미터에 대입하는 중에 실수할 가능성이 높을 뿐 아니라, 파라미터를 불변 값으로 강제하는 편이 더 깔끔하고 이해하기 편한 코드를 만들어내기 때문**이다.

- 코틀린은 **Call By Value** 를 사용한다.
  - 즉, **호출하는 쪽의 인자를 `복사` 한다** 는 뜻이다.
  - 호출 인자로 전달한 변수를 변경해도, 호출된 함수 내부의 파라미터 값에는 영향이 없다.
- 하지만, **파라미터가 참조 타입이라면, 호출한 쪽의 데이터는 그대로 남아있고, 이 데이터에 대한 참조만 복사된다.**
- 파라미터 자체는 함수 내부에서 바뀔 수 없지만, **일반적으로 파라미터가 가리키는 데이터는 바뀔 수 있다.**

```kt
fun main() {
    val a = intArrayOf(1, 2, 3)
    println(increment(a)) // 2
    println(a.contentToString()) // [2, 2, 3] 
}

fun increment(a: IntArray): Int {
    return ++a[0]
}
```

- 타입 지정을 생략해도 되는 변수와 달리(타입 추론이 가능했으므로), **파라미터에는 항상 타입을 지정해야** 한다.
  - 컴파일러는 함수 정의에서 파라미터 타입을 추론하지 못한다.
  - *모든 언어의 컴파일러가 파라미터 타입을 추론하지 못하는 것은 아니다. 특히 함수형 프로그래밍 언어의 컴파일러는 대부분 함수 정의의 파라미터의 타입도 가장 일반화된 타입으로 추론을 해준다. 이런 차이는 채택하는 타입 추론 엔진이 달라서 생기는 것이다.*
- 반면에, **반환 타입은 함수 파라미터에서 추론이 가능함에도 여전히 명시해야만 한다.**
  - 이는, 함수에서 결괏값을 결정해 외부로 나가는 지점(return으로 값을 반환하는 지)이 여러 곳일 수 있는데, 함수 본문의 모든 반환 지점을 살펴보고 반환 타입을 알아내기 어려울 수 있기 때문이다.
  - 함수 정의에 있는 반환 타입은 일종의 문서화 역할을 하며, 함수 정의의 첫 줄만 보고도 함수가 만들어내는 값이 무엇인지 바로 알 수 있게 해준다.
- 하지만, 경우에 따라 반환 타입을 생략할 수도 있다. (2가지 예외)
  - **1. 유닛(unit) 타입을 반환하는 경우**
    - unit은 자바의 void에 해당하는 코틀린 타입으로, 함수가 의미 있는 반환값을 돌려주지 않는다는 뜻이다.
    - 이런 함수가 반환하는 값은 Unit이라는 내장 타입에 속하는 Unit이라는 상수이다.
    - 함수 정의에서 반환값 타입을 지정하지 않으면, 코틀린은 Unit 함수를 정의한다고 가정한다.
    ```kt
    다음 두 코드는 동일한 의미이다.

    fun say(name: String) {
        println("Hello $name!")
    }

    fun say(name: String) : Unit {
        println("Hello $name!")
    }
    ```

  - **2. 식이 본문인 함수**
    - 함수가 단일 식으로만 구현될 수 있다면, return 키워드와 블록을 만드는 중괄호(`{}`)를 생략하고, 반환 타입과 함수 본문 식 사이에 `=`가 들어가 있다는 점이다.
    ```kt
    fun circleArea(radius: Double): Double = PI*radius*radius // 반환값이 Double로 추론된다.
    ```
    - 남용하지는 말고, **복잡하게 표현된 식이 본문인 함수는 일반적인 블록 구문을 사용해 가독성을 높여주는 편이 낫다.**

블록이 본문인 함수를 정의할 때, `{}` 앞에 `=`를 넣으면 이 블록이 익명 함수를 기술하는 **람다**로 해석되기 때문에, 원하는 결과를 얻을 수 없을 것이다.

```kt
fun circleArea(radius: Double) = {
    PI*radius*radius
}
```

- 위의 함수는, *미리 정해진 반지름에 해당하는 원의 넓이를 계산해주는 다른 함수를 반환하는 함수 정의* 이다.(올바른 정의임)
- 반면에 다음과 같이 `return` 을 추가하면, 컴파일 오류가 발생한다.

```kt
fun circleArea(radius: Double) = {
    return PI*radius*radius
}

/**

ErrorMessage는 다음과 같다.

'return' is not allowed here
Type mismatch: inferred type is () -> [Error type: Return not allowed] but Double was expected

이 오류는 타입 불일치로 인해 발생하며, 식이 본문인 함수 안에서 return 문이 금지되기 때문이다.
*/
```

### 3.1.2 위치 기반 인자와 이름 붙은 인자

- 함수 호출 인자는 순서대로 파라미터에 전달된다.
- 첫 번째 인자 -> 첫 번째 파라미터
- 두 번째 인자 -> 두 번째 파라미터
- 이러한 방식의 인자 전달을 **위치 기반 인자(positional argument)** 라고 한다.

위치 기반 인자는 여러 언어에서도 널리 쓰고 있다. 반면, 코틀린은 이름 붙은 인자(named argument)라고 불리는 방식도 제공한다.

이름 붙은 인자란, 위치가 아니라 파라미터의 이름을 명시함으로써 인자를 전달하는 방식이다.

```kt
fun say(name: String, age: Int) {
    println("안녕하세요. 저는 $name 입니다. $age 살입니다.")
}
```

위와 같은 함수가 있다고 해보자. 다음과 같이 호출해도 된다.

```kt
fun main() {
    say(name = "뉴진스 하니", age = 19) // 안녕하세요. 저는 뉴진스 하니 입니다. 19 살입니다.
    say(age = 19, name = "뉴진스 하니") // 안녕하세요. 저는 뉴진스 하니 입니다. 19 살입니다.
}
```

즉, 인자의 순서는 중요하지 않다.

코틀린 1.4 부터는 위치 기반 인자와 이름 붙은 인자를 섞어서 사용할 수 있다.
다만, 원래 인자가 들어가야 할 위치에 이름 붙은 인자를 지정해야 정상처리가 된다.

**성공하는 케이스**
```kt
fun main() {
    say(name = "뉴진스 하니", 19) // 안녕하세요. 저는 뉴진스 하니 입니다. 19 살입니다.
}
```

**실패하는 케이스**

```kt
fun main() {
    say(19, name = "뉴진스 하니") // ERROR !
}

/**
에러 메시지는 다음과 같다.

The integer literal does not conform to the expected type String
An argument is already passed for this parameter
No value passed for parameter 'age'
*/
```

### 3.1.3 오버로딩과 디폴트 값

- 코틀린에서도 이름이 같은 여럿 함수를 작성할 수 있다.
- 다만, **컴파일러가 어떤 함수를 호출해야할 지 구분할 수 있도록, 오버로딩한 함수의 파라미터 타입이 모두 달라야 한다.**

```kt
fun main() {
    say("뉴진스 하니", 19) // 안녕하세요. 저는 뉴진스 하니 입니다. 19 살입니다.
    say("뉴진스 하니") // 안녕하세요. 저는 뉴진스 하니 입니다. 나이는 안알려줄꺼에요ㅎㅎ
}

fun say(name: String, age: Int) {
    println("안녕하세요. 저는 $name 입니다. $age 살입니다.")
}

fun say(name: String) {
    println("안녕하세요. 저는 $name 입니다. 나이는 안알려줄꺼에요ㅎㅎ")
}
```

**오버 로딩 호출 규칙**

1. 파라미터의 개수와 타입을 기준으로 호출할 수 있는 모든 함수를 찾는다.
2. 덜 구체적인 함수를 제외시킨다.
   - 예를 들어, 규칙 1에서 선택한 후보 목록에서 어떤 함수의 파라미터 타입이 다른 함수의 파라미터 타입의 상위 타입(supertype)인 경우, 이 함수는 다른 함수보다 덜 구체적인 함수이다. 덜 구체적인 함수가 모두 제외가 될 때까지 이 단계를 반복한다.
3. 후보가 하나로 압축되면, 이 함수가 호출할 함수가 된다. 후보가 둘 이상이면 컴파일 오류가 발생한다.

예제를 보자. 다음과 같은 함수가 있다고 가정하자.

```kt
fun mul(a: Int, b:Int) = a*b // 1 
fun mul(a: Int, b: Int, c: Int) = a*b*c // 2
fun mul(s: String, n: Int) = s.repeat(n) // 3
fun mul(o: Any, n: Int) = Array(n) { o } // 4
```

이 때, 다음 함수를 호출하면 1을 선택한다.
```kt
mul(1,2) // Int가 Any의 하위 타입이므로, 4가 아닌 1을 선택한다.
```

만약, 다음과 같이 호출한다면?

```kt
mul(1, 2L) // (Int, Long)을 받을 수 있는 타입이 없기 때문에 컴파일 에러가 난다.
```

이번엔 반대로 앞에 인자를 Long 타입으로 호출한다면?

```kt
mul(1L, 2) // (Long, Int)를 받을 수 있는 타입은 4번 함수의 (Any, Int)이므로, 4번 함수가 호출된다.
```

이번엔 다음과 같이 String을 섞어볼까?
```kt
mul("0", 3) // 이때는 String이 Any의 하위 타입이기 때문에 3과 4중에 3을 선택하게 된다.
```

만약에 덜 구체적인 함수로 호출하고 싶은 경우에는 `as 타입 캐스팅` 연산자를 이용해 인자를 상위 타입으로 명시적으로 변환해야 한다.

```kt
mul("0" as Any, 3) // 이때는 Any, Int 를 받을 수 있는 함수가 4번 뿐이므로 4번이 호출된다.
```

> 디폴트 파라미터가 있는 함수
 
만약에 다음과 같은 함수가 해보자.

```kt
fun restrictToRange(
    from: Int = Int.MIN_VALUE,
    to: Int = Int.MAX_VALUE,
    what: Int) : Int = Math.max(from, Math.min(to, what))
```

```kt
fun main() {
	println(restrictToRange(10, what=1))
}
````

- 디폴트 파라미터가 있는 함수에서, 디폴트가 지정되지 않은 파라미터가 있는 경우엔, 디폴트 파라미터를 지정하지 않고 이 함수를 호출하는 유일한 방법은 **이름 붙은 인자를 활용하는 것** 이다.
- 하지, 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 것이 더 좋은 코딩스타일이다.
- 디폴트 값이 있으면, 오버로딩 해소가 조금 복잡해질 수 있다. 다음과 같은 상황을 보자.

```kt
fun mul(a: Int, b: Int = 1) = a*b // 1
fun mul(a: Int, b: Long = 1L) = a*b // 2
fun mul(a: Int, b: Int, c: Int = 1) = a*b*c // 3
```

위와 같음 함수에 대해서, 다음과 같이 호출하면 어떨까?

```kt
mul(10) // 오류 : 1과 2 중에 어느 쪽을 호출해야할 지 결정할 수 없다.
mul(10, 20) // 1과 3을 선택할 수 있지만, 인자가 1이 더 적기 때문에 1을 선택한다. (더 구체적인 함수를 선택한다.)
mul(10, 20, 30) // 적용 가능한 함수가 3번 뿐이므로, 3을 선택한다.
```

여기서 mul(10, 20)의 결과를 보자.
`1과 3을 선택할 수 있지만, 인자가 1이 더 적기 때문에 1을 선택한다. (더 구체적인 함수를 선택한다.)`

만약에 1의 함수가 다음과 같았다면 어떨까?

```kt
fun mul(a: Number, b: Int = 1) = a*b
```

이 경우, Number가 1의 상위 타입이기 때문에, 1번 함수가 3번 함수보다 덜 구체적인 함수로 간주되어, mul(10, 20)은 3번 함수를 선택하게 된다. [참고](https://pl.kotl.in/ycCsH0yrx)


### vararg

- 인자의 개수가 정해지지 않은 경우, arrayOf() 와 같은 함수를 사용할 수 있다.
- 그런데, 이번엔 함수로 넘기는 경우를 알아본다.
- 자바에서는 인자의 개수가 정해지지 않은 경우, ...(스프레드 연산자)를 통해서 파라미터를 받았었다.
- 코틀린에서는 이를 `vararg` 변경자(modifier)로 받는다.

```kt
@Test
fun vararg() {
    sortAndPrint('D', 'o', 'l', 'p', 'h', 'a', 'G', 'o')
}

private fun sortAndPrint(vararg list: Char) {
    list.sort()
    println(list) // DGahloop
}
```

또한 스프레드 연산자인 `*`를 사용하면, **배열**을 가변 인자 대신 넘길 수 있다.

```kt
@Test
fun vararg() {
    val list = charArrayOf('D', 'o', 'l', 'p', 'h', 'a', 'G', 'o')
    sortAndPrint(*list)
}

private fun sortAndPrint(vararg list: Char) {
    list.sort()
    println(list) // DGahloop
}
````

**스프레드는 배열을 복사한다는 점에 유의해야 한다.** 따라서 파라미터 배열의 내용을 바꿔도 원본에는 영향을 미치지 않는다.

```kt
@Test
fun vararg() {
    val list = charArrayOf('D', 'o', 'l', 'p', 'h', 'a', 'G', 'o')
    sortAndPrint(*list) // DGahloop
    print(list) // DolphaGo
}

private fun sortAndPrint(vararg list: Char) {
    list.sort()
    println(list)
}
```

하지만, 이 때 **얕은 복사가 이뤄지기 때문에 배열 내부에 참조가 들어있는 경우, 참조가 복사되기 때문에 참조가 가리키는 데이터가 호출하는 쪽과 함수 내부 배열에서 공유가 된다.**

```kt
@Test
fun vararg() {
    val list1 = charArrayOf('D', 'o', 'l', 'p', 'h', 'a', 'G', 'o')
    val list2 = charArrayOf('A', 'l', 'p', 'h', 'a', 'G', 'o')
    changeFirstCharAsT(list1, list2)
    println(list1) // TolphaGo
    println(list2) // AlphaGo
}

private fun changeFirstCharAsT(vararg list: CharArray) {
    list[0][0] = 'T'
    println(list[0]) // TolphaGo
    println(list[1]) // AlphaGo
}
```

둘 이상을, vararg 파라미터로 선언하는 것은 금지된다.

하지만, vararg 파라미터에 콤마로 분리한 여러 인자와 스프레드를 섞어서 전달하는 것은 괜찮다.

```kt
sortAndPrint('a', *list1, *charArrayOf('z', 'A'), 'u') // a, D, o, l, p, h, a, G, o, z, A, u 순으로 배열이 전달됨
```





## 3.2 패키지와 임포트

## 3.3 조건문

## 3.4 루프

## 3.5 예외처리

## 3.6 결론